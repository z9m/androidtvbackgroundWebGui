<!DOCTYPE html>
<html>
<head>
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
    <title>TV Background Suite</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Abril+Fatface&family=Alice&family=Andika&family=Arvo:wght@400;700&family=Barrio&family=Bungee+Spice&family=Codystar&family=Creepster&family=Diplomata+SC&family=Ewert&family=Fascinate+Inline&family=Faster+One&family=Fira+Sans:wght@300;400;700&family=Flavors&family=Fredericka+the+Great&family=Honk&family=IBM+Plex+Sans:wght@300;400;700&family=Inter:wght@300;400;700&family=Jost:wght@300;400;700&family=Lacquer&family=Lato:wght@300;400;700&family=Manrope:wght@300;400;700&family=Merriweather:wght@300;400;700&family=Metal+Mania&family=Modak&family=Monoton&family=Montserrat:wght@300;400;700&family=Mulish:wght@300;400;700&family=Nabla&family=Nosifer&family=Nunito:wght@300;400;700&family=Open+Sans:wght@300;400;700&family=Oswald:wght@300;400;700&family=Playfair+Display:wght@400;700&family=Roboto:wght@300;400;700&family=Rubik+Beastly&family=Rubik+Vinyl&family=Shojumaru&family=Silkscreen&family=Space+Grotesk:wght@300;400;700&family=Special+Elite&family=Titillium+Web:wght@300;400;700&family=Urbanist:wght@300;400;700&family=Zilla+Slab+Highlight&display=swap" rel="stylesheet">
    <style>
        :root { --primary: #2e7d32; --bg: #0a0a0a; --panel: #181818; --text: #eee; --sidebar-w: 320px; }
        body { background: var(--bg); color: var(--text); font-family: 'Segoe UI', sans-serif; margin: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        .nav-tabs { display: flex; background: #000; padding: 0 20px; border-bottom: 1px solid #333; height: 50px; flex-shrink: 0; }
        .tab-link { padding: 15px 25px; cursor: pointer; border-bottom: 3px solid transparent; font-size: 14px; }
        .tab-link.active { border-bottom-color: var(--primary); background: var(--panel); }
        .tab-content { display: none; flex: 1; overflow: hidden; }
        .tab-content.active { display: flex; }
        .sidebar { width: var(--sidebar-w); background: var(--panel); border-right: 1px solid #333; padding: 20px; box-sizing: border-box; overflow-y: auto; display: flex; flex-direction: column; gap: 20px; }
        .main-view { flex: 1; display: flex; align-items: center; justify-content: center; padding: 40px; background: #111; position: relative; overflow: auto; }
        .control-group { border-bottom: 1px solid #333; padding-bottom: 15px; }
        h3 { font-size: 12px; text-transform: uppercase; color: #888; margin: 0 0 10px 0; }
        label { font-size: 11px; color: #666; display: block; margin-top: 8px; cursor: pointer; }
        input, select, button { padding: 8px; border-radius: 4px; border: 1px solid #444; background: #222; color: white; width: 100%; margin-top: 5px; box-sizing: border-box; }
        button { background: var(--primary); border: none; font-weight: bold; cursor: pointer; }
        button:hover { filter: brightness(1.2); }
        button:disabled, button:disabled:hover { background: #555; cursor: not-allowed; opacity: 0.7; filter: none; }
        .btn-export { background: #1565c0; margin-top: 20px; }
        #canvas-wrapper { width: 100%; max-width: 1200px; aspect-ratio: 16 / 9; background: #000; border: 2px solid #333; box-shadow: 0 20px 50px rgba(0,0,0,0.8); }
        .canvas-container { width: 100% !important; height: 100% !important; }
        canvas { width: 100% !important; height: 100% !important; }
        #settings-tab { padding: 40px; overflow-y: auto; flex-direction: column; align-items: center;}
        .settings-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; width: 100%; max-width: 1000px; }
        .gallery-container { padding: 20px; width: 100%; overflow-y: auto; }
        .gallery-section { margin-bottom: 40px; }
        .gallery-section h2 { color: #eee; border-bottom: 1px solid #333; padding-bottom: 10px; margin-bottom: 15px; font-size: 18px; }
        .gallery-horizontal { display: flex; overflow-x: auto; gap: 15px; padding-bottom: 15px; scrollbar-width: thin; scrollbar-color: var(--primary) #222; }
        .gallery-horizontal::-webkit-scrollbar { height: 8px; }
        .gallery-horizontal::-webkit-scrollbar-track { background: #222; }
        .gallery-horizontal::-webkit-scrollbar-thumb { background: var(--primary); border-radius: 4px; }
        .gallery-item { position: relative; height: 20vh; aspect-ratio: 16/9; overflow: hidden; border-radius: 4px; border: 1px solid #333; cursor: pointer; transition: transform 0.2s; flex-shrink: 0; }
        .gallery-item:hover { transform: scale(1.05); z-index: 10; border-color: var(--primary); }
        .gallery-item img { width: 100%; height: 100%; object-fit: cover; }
        .gallery-item .caption { position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.7); color: #fff; font-size: 10px; padding: 5px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .layout-card { background: #181818; border: 1px solid #333; padding: 15px; border-radius: 8px; margin-bottom: 15px; }
        .layout-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .layout-previews { display: flex; gap: 10px; overflow-x: auto; padding-bottom: 5px; }
        .layout-previews img { height: 60px; border-radius: 4px; border: 1px solid #444; cursor: pointer; }
    </style>
</head>
<body>

    <div class="nav-tabs">
        <div class="tab-link active" onclick="openTab(event, 'editor-tab')">üé® Layout Editor</div>
        <div class="tab-link" onclick="openTab(event, 'layouts-tab'); loadLayoutsList()">üíæ Saved Layouts</div>
        <div class="tab-link" onclick="openTab(event, 'gallery-tab'); loadGallery()">üñºÔ∏è Gallery</div>
        <div class="tab-link" onclick="openTab(event, 'settings-tab')">‚öôÔ∏è Provider Settings</div>
    </div>

    <div id="editor-tab" class="tab-content active">
        <div class="sidebar">
            <div class="control-group">
                <h3>Layout Management</h3>
                <button id="btn-save-changes" onclick="saveEditedImage()" style="background: #d32f2f; margin-bottom: 10px; display: none;">üíæ Save Changes</button>
                <label>Layout Name</label>
                <input type="text" id="layoutName" placeholder="e.g. Dark Mode Minimal" value="Default">
                <label>Tag Alignment</label>
                <select id="tagAlignSelect" onchange="updateVerticalLayout(); saveToLocalStorage()">
                    <option value="left">Left</option>
                    <option value="center" selected>Center</option>
                    <option value="right">Right</option>
                </select>
                <div style="margin-top:5px;">
                    <div style="display:flex; justify-content:space-between;"><label for="genreLimitSlider" style="font-size:11px; margin:0;">Genre Limit</label><span id="genreLimitVal" style="font-size:11px;">Max</span></div>
                    <input type="range" id="genreLimitSlider" min="1" max="6" value="6" oninput="updateGenreLimit()" style="margin-top:2px;">
                </div>
                <button onclick="saveLayout()" style="background: #00796b; margin-top: 10px;">üíæ Save Layout</button>
            </div>

            <div class="control-group">
                <h3>Logos & Icons</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                    <button onclick="addLogo('https://upload.wikimedia.org/wikipedia/commons/thumb/6/69/IMDB_Logo_2016.svg/1200px-IMDB_Logo_2016.svg.png')" style="grid-column: 1 / -1;">IMDb Logo</button>
                </div>
                <div id="icon-properties" style="display:none; margin-top:10px; border-top:1px solid #333; padding-top:10px;">
                    <label for="iconSizeInput">Icon Size</label>
                    <input type="number" id="iconSizeInput" min="10" max="500" oninput="updateIconSize()">
                    <div style="display:flex; align-items:center; gap:10px; margin-top:10px;">
                        <input type="checkbox" id="matchHeightToggle" onchange="toggleMatchHeight()" style="width:20px; height:20px; margin:0;">
                        <label for="matchHeightToggle" style="margin:0; cursor:pointer; font-size:11px;">Match Height to Neighbor</label>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <h3>Metadata Tags</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                    <button onclick="addMetadataTag('title', 'TITLE / LOGO')">Title/Logo</button>
                    <button onclick="addMetadataTag('year', '2024')">Year</button>
                    <button onclick="addMetadataTag('rating', 'IMDb: 8.5')">Rating (Text)</button>
                    <button onclick="addMetadataTag('rating_star', '8.5')">Rating (Star)</button>
                    <button onclick="addMetadataTag('rating_val', '8.5')">Rating (Value)</button>
                    <button onclick="addMetadataTag('runtime', '2h 15m')">Runtime</button>
                    <button onclick="addMetadataTag('genres', 'Action, Sci-Fi')">Genres</button>
                    <button onclick="addMetadataTag('overview', 'Movie description...')">Overview</button>
                    <button onclick="addMetadataTag('provider_source', 'Now available on...')">Provider Info</button>
                </div>
            </div>

            <div class="control-group">
                <h3>Preview Controls</h3>
                <button id="btn-shuffle" onclick="fetchRandomPreview()" style="background: #1565c0;">üé≤ Shuffle Preview</button>
                <p id="source-indicator" style="font-size: 9px; color: #555; text-align: center; margin-top: 5px;">Source: None</p>
            </div>

            <div class="control-group">
                <h3>Canvas</h3>
                <label for="resSelect">Resolution</label>
                <select id="resSelect" onchange="changeResolution()">
                    <option value="1080">1080p (Full HD)</option>
                    <option value="2160">2160p (4K)</option>
                </select>
                <label>Background Color</label>
                <div style="display:flex; gap:5px; align-items:center;">
                    <input type="color" id="bgColor" oninput="updateBgColor()" value="#000000" style="height:35px; width:60px;">
                    <button onclick="autoDetectBgColor(true)" style="margin-top:0; font-size: 11px;">‚ú® Auto-Detect</button>
                </div>
                <div style="display:flex; justify-content:space-between; margin-top:5px;">
                    <label style="font-size:10px; margin:0;">Brightness</label>
                    <span id="brightVal" style="font-size:10px;">20%</span>
                </div>
                <input type="range" id="bgBrightness" min="0" max="100" value="20" oninput="adjustAutoBrightness()" style="margin-top:2px;">
                <button onclick="mirrorBackground()" style="margin-top: 10px; background-color: #4a4a4a;">‚ÜîÔ∏è Mirror Background</button>
            </div>

            <div class="control-group">
                <h3>Background Effects</h3>
                <label>Effect Type</label>
                <select id="fadeEffect" onchange="updateFadeControls()">
                    <option value="custom">Custom Linear Fade</option>
                    <option value="bottom-left">Corner Fade: Bottom-Left</option>
                    <option value="bottom-right">Corner Fade: Bottom-Right</option>
                    <option value="top-left">Corner Fade: Top-Left</option>
                    <option value="top-right">Corner Fade: Top-Right</option>
                    <option value="vignette">Vignette Fade (Centered)</option>
                </select>
                <div id="ctrl-fade-radius" style="display:none;">
                    <label for="fadeRadius">Corner Radius</label>
                    <input type="range" id="fadeRadius" min="0" max="3000" value="1000" oninput="updateFades()">
                </div>
                <div id="ctrl-fade-left"><label for="fadeLeft">Left</label><input type="range" id="fadeLeft" min="0" max="3000" value="580" oninput="updateFades()"></div>
                <div id="ctrl-fade-right"><label for="fadeRight">Right</label><input type="range" id="fadeRight" min="0" max="3000" value="0" oninput="updateFades()"></div>
                <div id="ctrl-fade-top"><label for="fadeTop">Top</label><input type="range" id="fadeTop" min="0" max="2000" value="0" oninput="updateFades()"></div>
                <div id="ctrl-fade-bottom"><label for="fadeBottom">Bottom</label><input type="range" id="fadeBottom" min="0" max="2000" value="320" oninput="updateFades()"></div>
            </div>

            <div class="control-group" id="text-properties" style="display:none;">
                <h3>Text Properties</h3>
                <label for="fontSizeInput">Font Size</label>
                <input type="number" id="fontSizeInput" min="10" max="200" oninput="updateSelectedFontSize()">
                <label for="fontFamilySelect">Font Family</label>
                <select id="fontFamilySelect" onchange="updateSelectedFontFamily()">
                    <option value="Oswald" selected>Oswald</option>
                    <option value="Segoe UI">Segoe UI (System)</option>
                    <option value="Roboto">Roboto</option>
                    <option value="Open Sans">Open Sans</option>
                    <option value="Lato">Lato</option>
                    <option value="Montserrat">Montserrat</option>
                    <option value="Merriweather">Merriweather</option>
                    <option value="Playfair Display">Playfair Display</option>
                    <option value="Space Grotesk">Space Grotesque</option>
                    <option value="Nunito">Nunito</option>
                    <option value="Manrope">Manrope</option>
                    <option value="Jost">Jost</option>
                    <option value="Titillium Web">Titillium Web</option>
                    <option value="Mulish">Muli</option>
                    <option value="Urbanist">Urbanist</option>
                    <option value="Inter">Inter</option>
                    <option value="Abril Fatface">Abril Fatface</option>
                    <option value="Arvo">Arvo</option>
                    <option value="IBM Plex Sans">IBM Plex Sans</option>
                    <option value="Alice">Alice</option>
                    <option value="Fira Sans">Fira Sans</option>
                    <option value="Evolventa">Evolventa</option>
                    <option value="Andika">Andika</option>
                    <option value="Nabla">Nabla</option>
                    <option value="Honk">Honk</option>
                    <option value="Monoton">Monoton</option>
                    <option value="Rubik Beastly">Rubik Beastly</option>
                    <option value="Faster One">Faster One</option>
                    <option value="Creepster">Creepster</option>
                    <option value="Modak">Modak</option>
                    <option value="Silkscreen">Silkscreen</option>
                    <option value="Lacquer">Lacquer</option>
                    <option value="Zilla Slab Highlight">Zilla Slab Highlight</option>
                    <option value="Codystar">Codystar</option>
                    <option value="Fascinate Inline">Fascinate Inline</option>
                    <option value="Ewert">Ewert</option>
                    <option value="Nosifer">Nosifer</option>
                    <option value="Shojumaru">Shojumaru</option>
                    <option value="Bungee Spice">Bungee Spice</option>
                    <option value="Rubik Vinyl">Rubik Vinyl</option>
                    <option value="Special Elite">Special Elite</option>
                    <option value="Flavors">Flavors</option>
                    <option value="Barrio">Barrio</option>
                    <option value="Fredericka the Great">Fredericka the Great</option>
                    <option value="Metal Mania">Metal Mania</option>
                    <option value="Diplomata SC">Diplomata SC</option>
                </select>
                <button onclick="applyFontToAll()" style="margin-top: 5px; font-size: 11px; background-color: #4a4a4a;">Apply Font & Color to All Tags</button>
                <label for="fontColorInput">Text Color</label>
                <input type="color" id="fontColorInput" oninput="updateSelectedColor()" style="height:35px;">
                <div id="textAlignControl" style="display:none; margin-top:10px;">
                    <label style="margin-bottom:5px;">Text Alignment</label>
                    <div style="display:flex; gap:5px;">
                        <button onclick="setTextAlignment('left')" style="flex:1;">Left</button>
                        <button onclick="setTextAlignment('center')" style="flex:1;">Center</button>
                        <button onclick="setTextAlignment('right')" style="flex:1;">Right</button>
                    </div>
                </div>
                <div id="textBackgroundControl" style="display:none; margin-top:10px; border-top:1px solid #333; padding-top:10px;">
                    <div style="display:flex; align-items:center; gap:10px; margin-bottom:5px;">
                        <input type="checkbox" id="textBgEnable" onchange="toggleTextBackground()" style="width:20px; height:20px; margin:0;">
                        <label for="textBgEnable" style="margin:0; cursor:pointer; font-size:11px;">Background Box</label>
                    </div>
                    <div id="textBgSettings" style="display:none;">
                        <div style="display:flex; align-items:center; gap:10px; margin-bottom:5px;">
                            <input type="checkbox" id="textBgAuto" onchange="updateTextBackgroundSettings()" style="width:20px; height:20px; margin:0;">
                            <label for="textBgAuto" style="margin:0; cursor:pointer; font-size:11px;">Auto-Color (Match BG)</label>
                        </div>
                        <label for="textBgColor">Box Color</label>
                        <input type="color" id="textBgColor" oninput="updateTextBackgroundSettings()" style="height:35px;">
                        <div style="display:flex; justify-content:space-between; margin-top:5px;">
                            <label style="font-size:10px; margin:0;">Opacity</label>
                            <span id="textBgOpacityVal" style="font-size:10px;">50%</span>
                        </div>
                        <input type="range" id="textBgOpacity" min="0" max="100" value="50" oninput="updateTextBackgroundSettings()" style="margin-top:2px;">
                    </div>
                </div>
            </div>

            <div style="margin-top:auto">
                <button class="btn-export" onclick="saveImage()">üíæ Export JPG (Download)</button>
                <button onclick="saveToGallery()" style="background: #e65100; margin-top: 10px;">üìÇ Save to Gallery</button>
            </div>
        </div>

        <div class="main-view">
            <button onclick="toggleGrid()" style="position:absolute; top:20px; left:20px; width:auto; z-index:100; background-color: #4a4a4a; padding: 8px 15px; box-shadow: 0 2px 5px rgba(0,0,0,0.5);">üìè Toggle Grid</button>
            <div id="canvas-wrapper">
                <canvas id="mainCanvas"></canvas>
            </div>
        </div>
    </div>

    <div id="layouts-tab" class="tab-content">
        <div class="gallery-container" id="layouts-content">
            <p style="color:#888; text-align:center; margin-top:50px;">Loading layouts...</p>
        </div>
    </div>

    <div id="gallery-tab" class="tab-content">
        <div class="gallery-container" id="gallery-content">
            <p style="color:#888; text-align:center; margin-top:50px;">Loading images...</p>
        </div>
    </div>

    <div id="settings-tab" class="tab-content">
        <div class="settings-grid">
            <div class="sidebar" style="width:100%; border:1px solid #333; border-radius:8px;">
                <h3>General</h3>
                <div style="display:flex; align-items:center; gap:10px; margin-top:10px;">
                    <input type="checkbox" id="set-gen-overwrite" style="width:20px; height:20px; margin:0;" {% if config.general.overwrite_existing %}checked{% endif %}>
                    <label for="set-gen-overwrite" style="margin:0; cursor:pointer;">Overwrite Existing Images</label>
                </div>
            </div>

            <div class="sidebar" style="width:100%; border:1px solid #333; border-radius:8px;">
                <h3>Jellyfin</h3>
                <label for="set-jf-url">Server URL</label>
                <input type="text" id="set-jf-url" value="{{ config.jellyfin.url }}">
                <label for="set-jf-key">API Key</label>
                <input type="password" id="set-jf-key" value="{{ config.jellyfin.api_key }}">
                <label for="set-jf-user">User ID</label>
                <input type="text" id="set-jf-user" value="{{ config.jellyfin.user_id }}">
                <label for="set-jf-exclude">Excluded Libraries (comma separated)</label>
                <input type="text" id="set-jf-exclude" value="{{ config.jellyfin.excluded_libraries }}">
            </div>

            <div class="sidebar" style="width:100%; border:1px solid #333; border-radius:8px;">
                <h3>Plex</h3>
                <label for="set-plex-url">Server URL</label>
                <input type="text" id="set-plex-url" value="{{ config.plex.url }}">
                <label for="set-plex-token">Token</label>
                <input type="password" id="set-plex-token" value="{{ config.plex.token }}">
            </div>

            <div class="sidebar" style="width:100%; border:1px solid #333; border-radius:8px;">
                <h3>TMDB</h3>
                <label for="set-tmdb-key">API Key (Bearer Token)</label>
                <input type="password" id="set-tmdb-key" value="{{ config.tmdb.api_key }}">
                <label for="set-tmdb-lang">Language</label>
                <input type="text" id="set-tmdb-lang" value="{{ config.tmdb.language }}">
            </div>

            <div class="sidebar" style="width:100%; border:1px solid #333; border-radius:8px;">
                <h3>Radarr & Sonarr</h3>
                <label for="set-radarr-url">Radarr URL</label>
                <input type="text" id="set-radarr-url" value="{{ config.radarr.url }}">
                <label for="set-radarr-key">Radarr API Key</label>
                <input type="password" id="set-radarr-key" value="{{ config.radarr.api_key }}">
                <hr style="border-color:#333; margin:15px 0;">
                <label for="set-sonarr-url">Sonarr URL</label>
                <input type="text" id="set-sonarr-url" value="{{ config.sonarr.url }}">
                <label for="set-sonarr-key">Sonarr API Key</label>
                <input type="password" id="set-sonarr-key" value="{{ config.sonarr.api_key }}">
            </div>

            <div class="sidebar" style="width:100%; border:1px solid #333; border-radius:8px;">
                <h3>Other Services</h3>
                <label for="set-jellyseerr-url">Jellyseerr URL</label>
                <input type="text" id="set-jellyseerr-url" value="{{ config.jellyseerr.url }}">
                <label for="set-jellyseerr-key">Jellyseerr API Key</label>
                <input type="password" id="set-jellyseerr-key" value="{{ config.jellyseerr.api_key }}">
                <hr style="border-color:#333; margin:15px 0;">
                <label for="set-trakt-key">Trakt Client ID</label>
                <input type="password" id="set-trakt-key" value="{{ config.trakt.api_key }}">
                <label for="set-trakt-user">Trakt Username</label>
                <input type="text" id="set-trakt-user" value="{{ config.trakt.username }}">
                <label for="set-trakt-list">Trakt List Name</label>
                <input type="text" id="set-trakt-list" value="{{ config.trakt.listname }}">
            </div>

            <button onclick="saveSettings()" style="grid-column: 1 / -1; max-width: 400px; margin: 20px auto;">Save Settings</button>
        </div>
    </div>

    <div id="lightbox" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:1000; justify-content:center; align-items:center;">
        <span onclick="closeLightbox()" style="position:absolute; top:20px; right:35px; color:#fff; font-size:40px; cursor:pointer; user-select:none;">&times;</span>
        <img id="lightbox-img" style="max-width:90%; max-height:90%; object-fit:contain;">
        <span onclick="changeLightboxImage(-1)" style="position:absolute; top:50%; left:20px; color:#fff; font-size:40px; cursor:pointer; transform:translateY(-50%); user-select:none;">&#10094;</span>
        <span onclick="changeLightboxImage(1)" style="position:absolute; top:50%; right:20px; color:#fff; font-size:40px; cursor:pointer; transform:translateY(-50%); user-select:none;">&#10095;</span>
        <button id="lightbox-edit-btn" style="position:absolute; bottom:20px; right:20px; width:auto; padding:10px 20px; font-size:16px; background:#d32f2f; color:white; border:none; cursor:pointer; z-index:1001; border-radius:4px;">‚úèÔ∏è Edit</button>
    </div>

    <script>
        // --- GLOBAL FIXES ---
        (function() {
            const originalSetter = Object.getOwnPropertyDescriptor(CanvasRenderingContext2D.prototype, 'textBaseline').set;
            Object.defineProperty(CanvasRenderingContext2D.prototype, 'textBaseline', {
                set: function(value) {
                    if (value === 'alphabetical') value = 'alphabetic';
                    return originalSetter.call(this, value);
                },
                configurable: true
            });

            // Patch Textbox to render background covering padding
            fabric.Textbox.prototype._renderBackground = function(ctx) {
                if (!this.backgroundColor) return;
                var dim = this._getNonTransformedDimensions();
                ctx.fillStyle = this.backgroundColor;
                const pad = this.padding || 0;
                ctx.fillRect(
                    -dim.x / 2 - pad,
                    -dim.y / 2 - pad,
                    dim.x + pad * 2,
                    dim.y + pad * 2
                );
                this._removeShadow(ctx);
            };
        })();

        let canvas, mainBg = null;
        let fades = { left: null, right: null, top: null, bottom: null, corner: null };
        let scalingTimeout = null, lastFetchedData = null, lightboxImages = [], currentLightboxIndex = 0, loadedGalleryData = {};
        let gridEnabled = false, movingObjects = [], snapLines = { v: [], h: [] }, guideLines = [], currentEditingFile = null;
        const gridSize = 50;

        function updateSelectionUI(e) {
            const activeObj = canvas.getActiveObject();
            const textPanel = document.getElementById('text-properties');
            const iconPanel = document.getElementById('icon-properties');
            const alignControl = document.getElementById('textAlignControl');
            const bgControl = document.getElementById('textBackgroundControl');
            
            // Hide all initially
            textPanel.style.display = 'none';
            if (iconPanel) iconPanel.style.display = 'none';

            if (!activeObj) return;

            if (activeObj.type === 'image' && activeObj.dataTag === 'icon') {
                if (iconPanel) {
                    iconPanel.style.display = 'block';
                    document.getElementById('iconSizeInput').value = Math.round(activeObj.getScaledHeight());
                    const isMatchHeight = activeObj.matchHeight || false;
                    document.getElementById('matchHeightToggle').checked = isMatchHeight;
                    document.getElementById('iconSizeInput').disabled = isMatchHeight;
                }
            } else if (activeObj.type === 'i-text' || activeObj.type === 'textbox' || (activeObj.type === 'group' && (activeObj.dataTag === 'rating_star' || activeObj.dataTag === 'rating'))) {
                textPanel.style.display = 'block';
                
                let textObj = activeObj;
                if (activeObj.type === 'group') textObj = activeObj.getObjects().find(o => o.type === 'i-text');
                
                if (textObj) {
                    document.getElementById('fontSizeInput').value = textObj.fontSize;
                    document.getElementById('fontFamilySelect').value = textObj.fontFamily;
                    const color = new fabric.Color(textObj.fill);
                    document.getElementById('fontColorInput').value = "#" + color.toHex();
                }
                
                if (activeObj.type === 'textbox') {
                    alignControl.style.display = 'block';
                    if (bgControl) {
                        bgControl.style.display = 'block';
                        const hasBg = !!activeObj.backgroundColor;
                        document.getElementById('textBgEnable').checked = hasBg;
                        document.getElementById('textBgSettings').style.display = hasBg ? 'block' : 'none';
                        
                        if (hasBg) {
                            const c = new fabric.Color(activeObj.backgroundColor);
                            const source = c.getSource();
                            const isAuto = activeObj.autoBackgroundColor || false;
                            document.getElementById('textBgAuto').checked = isAuto;
                            document.getElementById('textBgColor').disabled = isAuto;
                            
                            if (source) {
                                const hex = "#" + ((1 << 24) + (source[0] << 16) + (source[1] << 8) + source[2]).toString(16).slice(1);
                                document.getElementById('textBgColor').value = hex;
                                const opacity = Math.round(source[3] * 100);
                                document.getElementById('textBgOpacity').value = opacity;
                                document.getElementById('textBgOpacityVal').innerText = opacity + "%";
                            }
                        }
                    }
                } else {
                    alignControl.style.display = 'none';
                    if (bgControl) bgControl.style.display = 'none';
                }
            }
        }

        function updateSelectedFontSize() {
            const activeObj = canvas.getActiveObject();
            if (activeObj) { 
                const newSize = parseInt(document.getElementById('fontSizeInput').value);
                let textObj = (activeObj.type === 'group') ? activeObj.getObjects().find(o => o.type === 'i-text') : activeObj;
                if (textObj) { 
                    textObj.set("fontSize", newSize); 
                    if(activeObj.type==='group') {
                        if (activeObj.dataTag === 'rating_star' || activeObj.dataTag === 'rating') {
                            const imgObj = activeObj.getObjects().find(o => o.type === 'image');
                            if (imgObj) {
                                imgObj.scaleToHeight(newSize);
                                textObj.set('left', imgObj.left + imgObj.getScaledWidth() + 10);
                                textObj.set('top', imgObj.top + (imgObj.getScaledHeight() - textObj.getScaledHeight()) / 2);
                            }
                        }
                        activeObj.addWithUpdate(); 
                    }
                    else activeObj.setCoords();
                    updateVerticalLayout();
                    canvas.requestRenderAll();
                    saveToLocalStorage();
                }
            }
        }

        function updateIconSize() {
            const activeObj = canvas.getActiveObject();
            if (activeObj && activeObj.type === 'image') {
                const newSize = parseInt(document.getElementById('iconSizeInput').value);
                activeObj.scaleToHeight(newSize);
                activeObj.setCoords();
                updateVerticalLayout();
                canvas.requestRenderAll();
                saveToLocalStorage();
            }
        }

        function updateSelectedFontFamily() {
            const activeObj = canvas.getActiveObject();
            if (activeObj) { 
                let textObj = (activeObj.type === 'group') ? activeObj.getObjects().find(o => o.type === 'i-text') : activeObj; 
                if(textObj) { 
                    const fontName = document.getElementById('fontFamilySelect').value;
                    document.fonts.load(`10px "${fontName}"`).then(() => {
                        textObj.set("fontFamily", fontName); 
                        if (textObj.type === 'i-text') textObj.set("text", textObj.text);
                        if(activeObj.type==='group') {
                            if (activeObj.dataTag === 'rating_star' || activeObj.dataTag === 'rating') {
                                const imgObj = activeObj.getObjects().find(o => o.type === 'image');
                                if (imgObj && textObj) {
                                    textObj.set('top', imgObj.top + (imgObj.getScaledHeight() - textObj.getScaledHeight()) / 2);
                                }
                            }
                            activeObj.addWithUpdate(); 
                        }
                        else activeObj.setCoords();
                        updateVerticalLayout();
                        canvas.requestRenderAll();
                        saveToLocalStorage();
                    });
                } 
            }
        }

        function applyFontToAll() {
            const fontName = document.getElementById('fontFamilySelect').value;
            const fontColor = document.getElementById('fontColorInput').value;
            if (!canvas) return;
            document.fonts.load(`10px "${fontName}"`).then(() => {
                canvas.getObjects().forEach(obj => {
                    if (obj.dataTag === 'overview') return;
                    if (obj.type === 'i-text' || obj.type === 'textbox') {
                        obj.set("fontFamily", fontName);
                        obj.set("fill", fontColor);
                        if (obj.type === 'i-text') obj.set("text", obj.text);
                        obj.setCoords();
                    } else if (obj.type === 'group') {
                        const textObj = obj.getObjects().find(o => o.type === 'i-text');
                        if (textObj) {
                            textObj.set("fontFamily", fontName);
                            textObj.set("fill", fontColor);
                            obj.addWithUpdate();
                        }
                    }
                });
                updateVerticalLayout();
                canvas.requestRenderAll();
                saveToLocalStorage();
            });
        }
        
        function setTextAlignment(align) {
            const activeObj = canvas.getActiveObject();
            if (activeObj && activeObj.type === 'textbox') {
                activeObj.set('textAlign', align);
                canvas.requestRenderAll();
                saveToLocalStorage();
            }
        }

        function toggleMatchHeight() {
            const activeObj = canvas.getActiveObject();
            if (activeObj && activeObj.type === 'image') {
                activeObj.matchHeight = document.getElementById('matchHeightToggle').checked;
                document.getElementById('iconSizeInput').disabled = activeObj.matchHeight;
                updateVerticalLayout();
                canvas.requestRenderAll();
                saveToLocalStorage();
            }
        }

        function toggleTextBackground() {
            const activeObj = canvas.getActiveObject();
            if (activeObj && activeObj.type === 'textbox') {
                const enabled = document.getElementById('textBgEnable').checked;
                document.getElementById('textBgSettings').style.display = enabled ? 'block' : 'none';
                if (enabled) {
                    activeObj.set('padding', 10);
                    activeObj.setCoords();
                    if (!activeObj.backgroundColor) {
                        document.getElementById('textBgAuto').checked = true;
                        document.getElementById('textBgOpacity').value = 50;
                    }
                    updateTextBackgroundSettings();
                } else {
                    activeObj.set('backgroundColor', '');
                    activeObj.set('padding', 0);
                    activeObj.setCoords();
                    activeObj.autoBackgroundColor = false;
                    canvas.requestRenderAll();
                    saveToLocalStorage();
                }
            }
        }

        function updateTextBackgroundSettings() {
            const activeObj = canvas.getActiveObject();
            if (!activeObj || activeObj.type !== 'textbox') return;
            
            const isAuto = document.getElementById('textBgAuto').checked;
            const opacity = parseInt(document.getElementById('textBgOpacity').value) / 100;
            document.getElementById('textBgOpacityVal').innerText = Math.round(opacity * 100) + "%";
            document.getElementById('textBgColor').disabled = isAuto;
            activeObj.autoBackgroundColor = isAuto;
            
            let r, g, b;
            if (isAuto) {
                const rgb = new fabric.Color(document.getElementById('bgColor').value).getSource();
                r = rgb[0]; g = rgb[1]; b = rgb[2];
                document.getElementById('textBgColor').value = "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            } else {
                const hex = document.getElementById('textBgColor').value;
                r = parseInt(hex.slice(1, 3), 16); g = parseInt(hex.slice(3, 5), 16); b = parseInt(hex.slice(5, 7), 16);
            }
            activeObj.set('backgroundColor', `rgba(${r}, ${g}, ${b}, ${opacity})`);
            canvas.requestRenderAll();
            saveToLocalStorage();
        }

        function updateSelectedColor() {
            const activeObj = canvas.getActiveObject();
            if (activeObj) { 
                let textObj = (activeObj.type === 'group') ? activeObj.getObjects().find(o => o.type === 'i-text') : activeObj; 
                if(textObj) { 
                    textObj.set("fill", document.getElementById('fontColorInput').value); 
                    if(activeObj.type==='group') activeObj.addWithUpdate(); 
                    canvas.renderAll(); 
                } 
            }
        }

        function applyTruncation(textbox, textToDisplay) {
            if (!canvas) return;
            const textSource = textToDisplay || textbox.fullMediaText || "";
            const oldState = canvas.renderOnAddRemove;
            canvas.renderOnAddRemove = false;
            textbox.set('text', textSource);
            textbox.initDimensions();
            const limit = textbox.fixedHeight || textbox.height;
            if (textbox.height > limit) {
                let words = textSource.split(' ');
                while (textbox.height > limit && words.length > 10) { words.splice(-10); textbox.set('text', words.join(' ') + '...'); textbox.initDimensions(); }
                while (textbox.height > limit && words.length > 0) { words.pop(); textbox.set('text', words.join(' ') + '...'); textbox.initDimensions(); }
            }
            canvas.renderOnAddRemove = oldState;
            canvas.requestRenderAll();
        }

        async function fetchRandomPreview() {
            const btn = document.getElementById('btn-shuffle');
            const indicator = document.getElementById('source-indicator');
            
            btn.disabled = true;
            const originalText = btn.innerText;
            btn.innerText = "‚è≥ Loading...";
            indicator.innerText = "Fetching...";
            
            try {
                const response = await fetch('/api/media/random');
                const data = await response.json();
                lastFetchedData = data;
                
                // 1. Assets vorladen (Preload) - noch nichts am Canvas √§ndern!
                const assetPromises = [];
                let newBgImg = null;
                let newLogoImg = null;

                if (data.backdrop_url) {
                    assetPromises.push(new Promise(resolve => {
                        const proxiedUrl = `/api/proxy/image?url=${encodeURIComponent(data.backdrop_url)}`;
                        fabric.Image.fromURL(proxiedUrl, (img) => { newBgImg = img; resolve(); }, { crossOrigin: 'anonymous' });
                    }));
                }
                if (data.logo_url) {
                    assetPromises.push(new Promise(resolve => {
                        const proxiedLogo = `/api/proxy/image?url=${encodeURIComponent(data.logo_url)}`;
                        fabric.Image.fromURL(proxiedLogo, (img) => { newLogoImg = img; resolve(); }, { crossOrigin: 'anonymous' });
                    }));
                }
                await Promise.all(assetPromises);

                // 2. Jetzt alles auf einmal anwenden (synchron)
                if (newBgImg) {
                    if (mainBg) canvas.remove(mainBg);
                    mainBg = newBgImg;
                    mainBg.set({ left: 0, top: 0, selectable: true, dataTag: 'background' });
                    const targetWidth = canvas.width * 0.70;
                    mainBg.scaleToWidth(targetWidth);
                    mainBg.set({ left: canvas.width - targetWidth, top: 0 });
                    canvas.add(mainBg); canvas.sendToBack(mainBg); 
                    updateFades(true);
                }

                await autoDetectBgColor(true, true);
                await previewTemplate(data, true, newLogoImg);
                saveToLocalStorage();
                canvas.requestRenderAll();
                indicator.innerText = "Source: " + data.source;
            } catch (err) { console.error(err); indicator.innerText = "Error loading preview"; }
            finally {
                btn.disabled = false;
                btn.innerText = originalText;
            }
        }

        function previewTemplate(mediaData, skipRender = false, preloadedLogo = null) {
            return new Promise((resolve) => {
                if (!canvas || !mediaData) { resolve(); return; }
                let promises = [];
                
                [...canvas.getObjects()].forEach(obj => {
                    if (obj.dataTag) {
                        let val = "";
                        switch(obj.dataTag) {
                            case 'title':
                                if (mediaData.logo_url && preloadedLogo) {
                                    // Benutze das vorgeladene Logo sofort (synchron)
                                    preloadedLogo.set({ left: obj.left, top: obj.top, dataTag: 'title' });
                                    const maxW = canvas.width * 0.55; 
                                    const maxH = canvas.height * 0.35; 
                                    const scale = Math.min(maxW / preloadedLogo.width, maxH / preloadedLogo.height) * 0.8;
                                    preloadedLogo.scale(scale);
                                    canvas.remove(obj); canvas.add(preloadedLogo);
                                } else if (mediaData.logo_url) {
                                    const p = new Promise(r => {
                                        const proxiedLogo = `/api/proxy/image?url=${encodeURIComponent(mediaData.logo_url)}`;
                                        fabric.Image.fromURL(proxiedLogo, function(img, isError) {
                                            if (isError || !img) { r(); return; }
                                            img.set({ left: obj.left, top: obj.top, dataTag: 'title' });
                                            const maxW = canvas.width * 0.55; 
                                            const maxH = canvas.height * 0.35; 
                                            const scale = Math.min(maxW / img.width, maxH / img.height) * 0.8;
                                            img.scale(scale);
                                            canvas.remove(obj); canvas.add(img); 
                                            r();
                                        }, { crossOrigin: 'anonymous' });
                                    });
                                    promises.push(p);
                                    return; 
                                } else { 
                                    val = mediaData.title || mediaData.Name;
                                    // Fix: If switching from Logo (Image) to Text, replace the object
                                    if (obj.type === 'image') {
                                        const is4K = document.getElementById('resSelect').value === '2160';
                                        const titleSize = is4K ? 120 : 80;
                                        const newText = new fabric.IText(val, { 
                                            left: obj.left, top: obj.top, 
                                            fontFamily: 'Oswald', fontSize: titleSize, 
                                            fill: 'white', shadow: '2px 2px 10px rgba(0,0,0,0.8)', 
                                            dataTag: 'title', editable: false 
                                        });
                                        canvas.remove(obj); canvas.add(newText);
                                    }
                                }
                                break;
                            case 'year': val = mediaData.year || mediaData.ProductionYear; break;
                            case 'rating': 
                                let r = mediaData.rating || mediaData.CommunityRating; 
                                if (r && r !== 'N/A' && !isNaN(parseFloat(r))) r = parseFloat(r).toFixed(1);
                                if (obj.type === 'group') {
                                    const t = obj.getObjects().find(o => o.type === 'i-text');
                                    if(t) { t.set({ text: (r && r !== 'N/A') ? `${r}` : '' }); obj.addWithUpdate(); }
                                    val = undefined;
                                } else {
                                    val = (r && r !== 'N/A') ? `IMDb: ${r}` : ''; 
                                }
                                break;
                            case 'rating_val': 
                                let rv = mediaData.rating || mediaData.CommunityRating; 
                                if (rv && rv !== 'N/A' && !isNaN(parseFloat(rv))) rv = parseFloat(rv).toFixed(1);
                                val = (rv && rv !== 'N/A') ? `${rv}` : ''; 
                                break;
                            case 'rating_star': 
                                let rs = mediaData.rating || mediaData.CommunityRating; 
                                if (rs && rs !== 'N/A' && !isNaN(parseFloat(rs))) rs = parseFloat(rs).toFixed(1);
                                val = (rs && rs !== 'N/A') ? `${rs}` : '';
                                if (obj.type === 'group') {
                                    const t = obj.getObjects().find(o => o.type === 'i-text');
                                    if(t) { t.set({ text: val }); obj.addWithUpdate(); }
                                    val = undefined; 
                                }
                                break;
                            case 'overview': 
                                let ov = mediaData.overview || mediaData.Overview || "";
                                if (obj.type === 'textbox') { obj.fullMediaText = ov; applyTruncation(obj, ov); } else { val = ov; }
                                break;
                            case 'genres': 
                                val = mediaData.genres || ""; 
                                const gLimit = parseInt(document.getElementById('genreLimitSlider').value);
                                if (gLimit < 6) {
                                    val = val.split(',').slice(0, gLimit).join(',');
                                }
                                break;
                            case 'runtime': 
                                val = mediaData.runtime || ""; 
                                const rtCheck = String(val).toLowerCase().replace(/\s/g, '');
                                if (rtCheck === '0min' || rtCheck === '0') {
                                    obj.set('visible', false);
                                } else {
                                    obj.set('visible', true);
                                }
                                break;
                            case 'provider_source':
                                const src = (mediaData.source || "").toLowerCase();
                                if (src === 'radarr' || src === 'sonarr') {
                                    val = "Available soon...";
                                } else if (src) {
                                    const pName = src === 'tmdb' ? 'TMDB' : src.charAt(0).toUpperCase() + src.slice(1);
                                    val = `Now available on ${pName}`;
                                }
                                break;
                        }
                        if (val !== undefined && obj.dataTag !== 'overview') obj.set({ text: String(val) });
                    }
                });
                
                Promise.all(promises).then(() => {
                    updateVerticalLayout(skipRender);
                    resolve();
                });
            });
        }

        let detectedBaseColor = null;

        function autoDetectBgColor(forceRecalc, skipRender = false) {
            if (!mainBg) return Promise.resolve();
            
            if (forceRecalc || !detectedBaseColor) {
                const img = mainBg.getElement();
                const cvs = document.createElement('canvas');
                cvs.width = img.naturalWidth || img.width;
                cvs.height = img.naturalHeight || img.height;
                const ctx = cvs.getContext('2d');
                ctx.drawImage(img, 0, 0);
                
                const frame = 50; 
                const w = cvs.width, h = cvs.height;
                let r=0, g=0, b=0, count=0;
                
                try {
                    const data = ctx.getImageData(0, 0, w, h).data;
                    const step = 20; 
                    for (let y=0; y<h; y+=step) {
                        for (let x=0; x<w; x+=step) {
                            if (x < frame || x > w-frame || y < frame || y > h-frame) {
                                const i = (y*w + x)*4;
                                r += data[i]; g += data[i+1]; b += data[i+2];
                                count++;
                            }
                        }
                    }
                } catch(e) { console.error("Pixel access error", e); return; }
                
                if (count > 0) {
                    detectedBaseColor = { r: Math.floor(r/count), g: Math.floor(g/count), b: Math.floor(b/count) };
                }
            }
            return applyBrightness(skipRender);
        }

        function adjustAutoBrightness() {
            document.getElementById('brightVal').innerText = document.getElementById('bgBrightness').value + '%';
            if (detectedBaseColor) {
                applyBrightness();
            } else if (mainBg) {
                autoDetectBgColor(true);
            }
        }

        function applyBrightness(skipRender = false) {
            if (!detectedBaseColor) return Promise.resolve();
            const factor = parseInt(document.getElementById('bgBrightness').value) / 100;
            let r = Math.floor(detectedBaseColor.r * factor);
            let g = Math.floor(detectedBaseColor.g * factor);
            let b = Math.floor(detectedBaseColor.b * factor);
            const hex = "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            document.getElementById('bgColor').value = hex;
            return updateBgColor(skipRender);
        }

        function addMetadataTag(type, placeholder) {
            let textObj;
            const count = canvas.getObjects().filter(o => o.dataTag).length;
            
            const is4K = document.getElementById('resSelect').value === '2160';
            const baseSize = is4K ? 54 : 35;
            const titleSize = is4K ? 120 : 80;
            const step = is4K ? 150 : 100;
            const props = { left: 100 + (count * 30), top: 100 + (count * step), fontFamily: 'Oswald', fontSize: type === 'title' ? titleSize : baseSize, fill: 'white', shadow: '2px 2px 10px rgba(0,0,0,0.8)', dataTag: type };
            
            if (type === 'rating_star') {
                const starUrl = 'https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/Gold_Star.svg/1024px-Gold_Star.svg.png';
                const proxiedUrl = `/api/proxy/image?url=${encodeURIComponent(starUrl)}`;
                fabric.Image.fromURL(proxiedUrl, function(img) {
                    if(!img) return;
                    img.scaleToHeight(props.fontSize).set({dataTag: 'rating_star_img'});
                    const text = new fabric.IText(placeholder, { ...props, left: img.getScaledWidth() + 10, top: 0, shadow: undefined, editable: false });
                    const group = new fabric.Group([img, text], { left: props.left, top: props.top, dataTag: type });
                    canvas.add(group);
                    canvas.setActiveObject(group);
                    if (lastFetchedData) previewTemplate(lastFetchedData);
                    else canvas.requestRenderAll();
                }, { crossOrigin: 'anonymous' });
                return;
            }
            
            if (type === 'rating') {
                const logoUrl = 'https://upload.wikimedia.org/wikipedia/commons/thumb/6/69/IMDB_Logo_2016.svg/1200px-IMDB_Logo_2016.svg.png';
                const proxiedUrl = `/api/proxy/image?url=${encodeURIComponent(logoUrl)}`;
                fabric.Image.fromURL(proxiedUrl, function(img) {
                    if(!img) return;
                    img.scaleToHeight(props.fontSize).set({dataTag: 'rating_logo_img'});
                    const textVal = placeholder.replace('IMDb: ', '');
                    const text = new fabric.IText(textVal, { ...props, left: img.getScaledWidth() + 10, top: 0, shadow: undefined, editable: false });
                    text.set('top', (img.getScaledHeight() - text.getScaledHeight()) / 2);
                    const group = new fabric.Group([img, text], { left: props.left, top: props.top, dataTag: type });
                    canvas.add(group);
                    canvas.setActiveObject(group);
                    if (lastFetchedData) previewTemplate(lastFetchedData);
                    else canvas.requestRenderAll();
                }, { crossOrigin: 'anonymous' });
                return;
            }

            if (type === 'overview') {
                textObj = new fabric.Textbox(placeholder, { ...props, width: 600, height: 300, fixedHeight: 300, splitByGrapheme: false, lockScalingY: false, fullMediaText: placeholder, editable: false });
            } else {
                textObj = new fabric.IText(placeholder, { ...props, editable: false });
            }
            canvas.add(textObj);
            canvas.setActiveObject(textObj);
            if (lastFetchedData) previewTemplate(lastFetchedData);
            else canvas.requestRenderAll();
        }

        function addLogo(url) {
            const proxiedUrl = `/api/proxy/image?url=${encodeURIComponent(url)}`;
            fabric.Image.fromURL(proxiedUrl, function(img) {
                if(!img) return;
                img.scaleToWidth(100);
                const count = canvas.getObjects().length;
                const offset = count * 20;
                img.set({ left: 100 + offset, top: 100 + offset });
                canvas.add(img);
                canvas.setActiveObject(img);
                canvas.requestRenderAll();
                updateVerticalLayout();
                saveToLocalStorage();
            }, { crossOrigin: 'anonymous', dataTag: 'icon' });
        }
        
        function updateGenreLimit() {
            const val = document.getElementById('genreLimitSlider').value;
            document.getElementById('genreLimitVal').innerText = (val == 6) ? "Max" : val;
            if (lastFetchedData) previewTemplate(lastFetchedData);
        }

        function groupElementsByRow(elements, threshold = 30) {
            if (!elements.length) return [];
            
            elements.sort((a, b) => a.top - b.top);
            
            const rows = [];
            let currentRow = [elements[0]];
            
            for (let i = 1; i < elements.length; i++) {
                if (Math.abs(elements[i].top - currentRow[0].top) < threshold) {
                    currentRow.push(elements[i]);
                } else {
                    rows.push(currentRow);
                    currentRow = [elements[i]];
                }
            }
            rows.push(currentRow);
            return rows;
        }

        function updateVerticalLayout(skipRender = false) {
            const padding = 20; // This is the minimum vertical distance
            const hPadding = 20; // Horizontal spacing between tags
            const rowThreshold = 30; // How close elements must be to be considered in the same row
            const screenMargin = 50; // Minimum distance from screen edges
            const alignment = document.getElementById('tagAlignSelect').value;

            // Sync text alignment for overview based on layout alignment
            canvas.getObjects().forEach(o => {
                if (o.dataTag === 'overview' && o.type === 'textbox') {
                    o.set('textAlign', alignment);
                }
            });

            const anchor = canvas.getObjects().find(o => o.dataTag === 'title');
            if (!anchor) { canvas.requestRenderAll(); return; }

            // Ensure anchor (Logo/Title) respects screen margin
            if (anchor.left < screenMargin) anchor.set('left', screenMargin);
            if (anchor.left + anchor.getScaledWidth() > canvas.width - screenMargin) {
                anchor.set('left', Math.max(screenMargin, canvas.width - screenMargin - anchor.getScaledWidth()));
            }
            
            // Vertical constraint for anchor (Top & Bottom)
            if (anchor.top < screenMargin) anchor.set('top', screenMargin);
            if (anchor.top + anchor.getScaledHeight() > canvas.height - screenMargin) {
                anchor.set('top', Math.max(screenMargin, canvas.height - screenMargin - anchor.getScaledHeight()));
            }
            anchor.setCoords();

            let current_y = anchor.top + anchor.getScaledHeight() + padding;
            
            const elements = canvas.getObjects().filter(o => {
                if (o === mainBg) return false; // Explicitly exclude mainBg
                if (o.dataTag === 'background') return false;
                if (o.dataTag === 'title') return false;
                if (o.dataTag === 'guide') return false;
                if (o.dataTag === 'fade_effect') return false;
                if (o.dataTag === 'grid_line') return false;
                if (!o.dataTag) return false;
                if (!o.visible) return false;
                return true;
            });
            const rows = groupElementsByRow(elements, rowThreshold);

            if (rows.length > 0) {
                let maxRowWidth = 0;
                rows.forEach(row => {
                    let w = 0;
                    row.forEach((el, i) => {
                        w += el.getScaledWidth();
                        if (i < row.length - 1) w += hPadding;
                    });
                    if (w > maxRowWidth) maxRowWidth = w;
                });

                const anchorW = anchor.getScaledWidth();
                let shift = 0;

                if (alignment === 'center') {
                    const idealStart = anchor.left + (anchorW - maxRowWidth) / 2;
                    if (idealStart < screenMargin) shift = screenMargin - idealStart;
                    else if (idealStart + maxRowWidth > canvas.width - screenMargin) shift = (canvas.width - screenMargin - maxRowWidth) - idealStart;
                } else if (alignment === 'right') {
                    const idealStart = (anchor.left + anchorW) - maxRowWidth;
                    if (idealStart < screenMargin) shift = screenMargin - idealStart;
                } else { // left
                    const idealStart = anchor.left;
                    if (idealStart + maxRowWidth > canvas.width - screenMargin) shift = (canvas.width - screenMargin - maxRowWidth) - idealStart;
                }

                if (shift !== 0) { anchor.set('left', anchor.left + shift); anchor.setCoords(); }
            }

            const anchorLeft = anchor.left;
            const anchorWidth = anchor.getScaledWidth();

            rows.forEach(row => {
                // Auto-resize icons if enabled (Match Height)
                const resizableIcons = row.filter(el => el.type === 'image' && el.matchHeight);
                if (resizableIcons.length > 0) {
                    const ref = row.find(el => (el.type === 'i-text' || el.type === 'textbox' || el.type === 'group') && !el.matchHeight);
                    if (ref) {
                        const targetH = ref.getScaledHeight();
                        resizableIcons.forEach(icon => {
                            if (Math.abs(icon.getScaledHeight() - targetH) > 0.5) {
                                icon.scaleToHeight(targetH);
                                icon.setCoords();
                            }
                        });
                    }
                }

                // Sort elements in this row by their X position (left to right)
                row.sort((a, b) => a.left - b.left);
                
                // Calculate total width of this row
                let totalRowWidth = 0;
                row.forEach((el, index) => {
                    totalRowWidth += el.getScaledWidth();
                    if (index < row.length - 1) totalRowWidth += hPadding;
                });

                // Determine starting X: Center relative to logo (even if wider), else align left
                let current_x;
                if (alignment === 'center') {
                    current_x = anchorLeft + (anchorWidth - totalRowWidth) / 2;
                } else if (alignment === 'right') {
                    current_x = (anchorLeft + anchorWidth) - totalRowWidth;
                } else {
                    current_x = anchorLeft;
                }

                // Ensure tags don't go off-screen (apply margins)
                if (current_x < screenMargin) current_x = screenMargin;
                if (current_x + totalRowWidth > canvas.width - screenMargin) {
                    current_x = Math.max(screenMargin, canvas.width - screenMargin - totalRowWidth);
                }

                const maxRowHeight = Math.max(...row.map(el => el.getScaledHeight()));
                
                // Stack elements horizontally starting from the calculated current_x
                row.forEach(el => {
                    el.set({ top: current_y, left: current_x });
                    el.setCoords(); // Update coordinates for accurate width calculation
                    current_x += el.getScaledWidth() + hPadding;
                });
                
                current_y += maxRowHeight + padding;
            });

            // Check for bottom overflow and shift up if necessary
            const contentBottom = current_y - padding;
            const maxBottom = canvas.height - screenMargin;
            
            if (contentBottom > maxBottom) {
                const shift = contentBottom - maxBottom;
                const maxShift = anchor.top - screenMargin;
                const actualShift = Math.min(shift, maxShift);
                
                if (actualShift > 0) {
                    anchor.set('top', anchor.top - actualShift);
                    rows.forEach(row => row.forEach(el => el.set('top', el.top - actualShift)));
                }
            }

            canvas.getObjects().forEach(o => o.setCoords());
            if (!skipRender) canvas.requestRenderAll();
        }

        function toggleGrid() {
            gridEnabled = !gridEnabled;
            if (gridEnabled) drawGrid();
            else removeGrid();
            canvas.requestRenderAll();
        }

        function drawGrid() {
            removeGrid();
            const w = canvas.width, h = canvas.height;
            const opts = { stroke: '#555', strokeDashArray: [5, 5], selectable: false, evented: false, dataTag: 'grid_line' };
            for (let i = 1; i < (w / gridSize); i++) canvas.add(new fabric.Line([ i * gridSize, 0, i * gridSize, h], opts));
            for (let i = 1; i < (h / gridSize); i++) canvas.add(new fabric.Line([ 0, i * gridSize, w, i * gridSize], opts));
            
            const gridLines = canvas.getObjects().filter(o => o.dataTag === 'grid_line');
            const fadeObjs = canvas.getObjects().filter(o => o.dataTag === 'fade_effect');
            
            gridLines.forEach(o => canvas.sendToBack(o));
            fadeObjs.forEach(o => canvas.sendToBack(o));
            if (mainBg) canvas.sendToBack(mainBg);
        }
        
        function drawGuide(x1, y1, x2, y2) {
            const l = new fabric.Line([x1, y1, x2, y2], { stroke: 'cyan', strokeWidth: 1, strokeDashArray: [4, 4], selectable: false, evented: false, dataTag: 'guide' });
            canvas.add(l); guideLines.push(l);
        }
        function clearGuides() { guideLines.forEach(l => canvas.remove(l)); guideLines = []; }

        function removeGrid() {
            const gridLines = canvas.getObjects().filter(o => o.dataTag === 'grid_line');
            gridLines.forEach(o => canvas.remove(o));
        }

        function init() {
            canvas = new fabric.Canvas('mainCanvas', { width: 1920, height: 1080, backgroundColor: '#000000', preserveObjectStacking: true });
            canvas.renderOnAddRemove = false;
            fabric.Object.prototype.objectCaching = true;

            canvas.on('object:scaling', (e) => {
                const t = e.target;
                if (t instanceof fabric.Textbox) {
                    t.set({ width: t.width * t.scaleX, fixedHeight: t.height * t.scaleY, scaleX: 1, scaleY: 1 });
                    if (t.dataTag === 'overview') { clearTimeout(scalingTimeout); scalingTimeout = setTimeout(() => applyTruncation(t, t.fullMediaText), 50); }
                }
                if (t === mainBg) updateFades();
                canvas.requestRenderAll();
                saveToLocalStorage();
            });

            canvas.on('mouse:down', (e) => {
                const active = e.target;
                if (!active || !active.selectable || active === mainBg) return;
                snapLines = { v: [], h: [] };
                if (!gridEnabled) {
                    canvas.getObjects().forEach(obj => {
                        if (obj === active || !obj.selectable || !obj.visible || obj.dataTag === 'guide') return;
                        const b = obj.getBoundingRect();
                        snapLines.h.push(b.top, b.top + b.height, b.top + b.height / 2);
                        snapLines.v.push(b.left, b.left + b.width, b.left + b.width / 2);
                    });
                }
            });
            
            canvas.on('object:moving', (e) => { 
                const active = e.target;
                if (active === mainBg) { updateFades(); return; }

                if (gridEnabled) {
                    active.set({
                        left: Math.round(active.left / gridSize) * gridSize,
                        top: Math.round(active.top / gridSize) * gridSize
                    });
                } else { 
                    const threshold = 10;
                    const b = active.getBoundingRect();
                    const pts = { x: [b.left, b.left + b.width, b.left + b.width/2], y: [b.top, b.top + b.height, b.top + b.height/2] };
                    
                    clearGuides();

                    for (const line of snapLines.v) {
                        for (const pt of pts.x) {
                            if (Math.abs(pt - line) < threshold) {
                                active.set({ left: active.left + (line - pt) });
                                drawGuide(line, 0, line, canvas.height);
                                canvas.requestRenderAll();
                                return;
                            }
                        }
                    }
                    for (const line of snapLines.h) {
                        for (const pt of pts.y) {
                            if (Math.abs(pt - line) < threshold) {
                                active.set({ top: active.top + (line - pt) });
                                drawGuide(0, line, canvas.width, line);
                                canvas.requestRenderAll();
                                return;
                            }
                        }
                    }
                }
            });
            
            canvas.on('mouse:up', (e) => {
                try {
                    clearGuides();
                    if (e.target && e.target.dataTag) {
                        setTimeout(() => {
                            updateVerticalLayout();
                            saveToLocalStorage();
                        }, 0);
                    }
                } catch (err) { console.error("Error in mouse:up", err); }
            });

            canvas.on('selection:created', updateSelectionUI);
            canvas.on('selection:updated', updateSelectionUI);
            canvas.on('selection:cleared', updateSelectionUI);
            
            canvas.on('object:modified', saveToLocalStorage);
            canvas.on('object:added', saveToLocalStorage);
            canvas.on('object:removed', saveToLocalStorage);
            canvas.on('text:changed', saveToLocalStorage);
            
            window.addEventListener('keydown', (e) => {
                const active = canvas.getActiveObject();
                if (active && (active.type === 'i-text' || active.type === 'textbox') && active.isEditing) return;

                if (e.key === "Delete" || e.key === "Backspace") {
                    canvas.getActiveObjects().forEach(obj => { if (obj === mainBg) mainBg = null; canvas.remove(obj); });
                    canvas.discardActiveObject().requestRenderAll();
                }
            });

            if (!loadFromLocalStorage()) {
                loadBackground("{{ data.backdrop_url }}");
            }
            updateFadeControls();
        }

        function loadBackground(url, skipRender = false) {
            return new Promise((resolve) => {
                const proxiedUrl = url.startsWith('http') ? `/api/proxy/image?url=${encodeURIComponent(url)}` : url;
                fabric.Image.fromURL(proxiedUrl, function(img, isError) {
                    if (isError || !img) { resolve(); return; }
                    if (mainBg) canvas.remove(mainBg);
                    mainBg = img;
                    img.set({ left: 0, top: 0, selectable: true, dataTag: 'background' });
                
                    const targetWidth = canvas.width * 0.70;
                    img.scaleToWidth(targetWidth);
                    img.set({ left: canvas.width - targetWidth, top: 0 });
                
                    canvas.add(img); canvas.sendToBack(img); updateFades(skipRender);
                    resolve();
                    saveToLocalStorage();
                }, { crossOrigin: 'anonymous' });
            });
        }

        function updateFadeControls() {
            const type = document.getElementById('fadeEffect').value;
            const show = (id) => document.getElementById(id).style.display = 'block';
            const hide = (id) => document.getElementById(id).style.display = 'none';
            const radiusLabel = document.querySelector('label[for="fadeRadius"]');

            ['ctrl-fade-radius', 'ctrl-fade-left', 'ctrl-fade-right', 'ctrl-fade-top', 'ctrl-fade-bottom'].forEach(show);

            if (type === 'custom') {
                hide('ctrl-fade-radius');
            } else if (type === 'bottom-left') {
                hide('ctrl-fade-top');
                hide('ctrl-fade-right');
                radiusLabel.innerText = "Corner Radius";
            } else if (type === 'bottom-right') {
                hide('ctrl-fade-top');
                hide('ctrl-fade-left');
                radiusLabel.innerText = "Corner Radius";
            } else if (type === 'top-left') {
                hide('ctrl-fade-bottom');
                hide('ctrl-fade-right');
                radiusLabel.innerText = "Corner Radius";
            } else if (type === 'top-right') {
                hide('ctrl-fade-bottom');
                hide('ctrl-fade-left');
                radiusLabel.innerText = "Corner Radius";
            } else if (type === 'vignette') {
                hide('ctrl-fade-left');
                hide('ctrl-fade-right');
                show('ctrl-fade-top');
                show('ctrl-fade-bottom');
                radiusLabel.innerText = "Vignette Radius";
            }
            updateFades();
        }

        function updateFades(skipRender = false) {
            if (!mainBg) return;
            const type = document.getElementById('fadeEffect').value;

            // Remove ALL existing fade effects from canvas to prevent stacking
            canvas.getObjects().filter(o => o.dataTag === 'fade_effect').forEach(o => canvas.remove(o));
            fades = {}; // Reset tracker

            const addLinear = (side) => {
                const el = document.getElementById('fade' + side.charAt(0).toUpperCase() + side.slice(1));
                if (el && el.value > 0) {
                    fades[side] = createFadeRect(side, el.value);
                    canvas.add(fades[side]);
                    fades[side].moveTo(canvas.getObjects().indexOf(mainBg) + 1);
                }
            };

            if (type === 'custom') {
                ['left', 'right', 'top', 'bottom'].forEach(addLinear);
            } else if (type === 'bottom-left') {
                addCornerFade('bottom-left');
                addLinear('left');
                addLinear('bottom');
            } else if (type === 'bottom-right') {
                addCornerFade('bottom-right');
                addLinear('right');
                addLinear('bottom');
            } else if (type === 'top-left') {
                addCornerFade('top-left');
                addLinear('left');
                addLinear('top');
            } else if (type === 'top-right') {
                addCornerFade('top-right');
                addLinear('right');
                addLinear('top');
            } else if (type === 'vignette') {
                addVignette();
                addLinear('top');
                addLinear('bottom');
            }
            if (!skipRender) canvas.requestRenderAll();
        }

        function addCornerFade(pos) {
            const r = parseInt(document.getElementById('fadeRadius').value);
            if (r <= 0) return;
            const bgColor = document.getElementById('bgColor').value;
            const w = mainBg.getScaledWidth(), h = mainBg.getScaledHeight();
            let rectLeft, rectTop, gradCx, gradCy;

            if (pos === 'bottom-left') {
                rectLeft = mainBg.left; rectTop = mainBg.top + h - r;
                gradCx = 0; gradCy = r;
            } else if (pos === 'bottom-right') {
                rectLeft = mainBg.left + w - r; rectTop = mainBg.top + h - r;
                gradCx = r; gradCy = r;
            } else if (pos === 'top-left') {
                rectLeft = mainBg.left; rectTop = mainBg.top;
                gradCx = 0; gradCy = 0;
            } else if (pos === 'top-right') {
                rectLeft = mainBg.left + w - r; rectTop = mainBg.top;
                gradCx = r; gradCy = 0;
            }

            const grad = new fabric.Gradient({
                type: 'radial',
                coords: { r1: 0, r2: r, x1: gradCx, y1: gradCy, x2: gradCx, y2: gradCy },
                colorStops: [{ offset: 0, color: bgColor }, { offset: 1, color: hexToRgba(bgColor, 0) }]
            });

            fades.corner = new fabric.Rect({ left: rectLeft, top: rectTop, width: r, height: r, fill: grad, selectable: false, evented: false, dataTag: 'fade_effect' });
            canvas.add(fades.corner);
            fades.corner.moveTo(canvas.getObjects().indexOf(mainBg) + 1);
        }

        function addVignette() {
            const r = parseInt(document.getElementById('fadeRadius').value);
            if (r <= 0) return;
            const bgColor = document.getElementById('bgColor').value;
            const padding = 10;
            const w = Math.ceil(mainBg.getScaledWidth()) + padding, h = Math.ceil(mainBg.getScaledHeight()) + padding;
            
            const grad = new fabric.Gradient({
                type: 'radial',
                coords: { r1: 0, r2: r, x1: w/2, y1: h/2, x2: w/2, y2: h/2 },
                colorStops: [{ offset: 0, color: hexToRgba(bgColor, 0) }, { offset: 1, color: bgColor }]
            });

            fades.corner = new fabric.Rect({ left: mainBg.left - (padding/2), top: mainBg.top - (padding/2), width: w, height: h, fill: grad, selectable: false, evented: false, dataTag: 'fade_effect' });
            canvas.add(fades.corner);
            fades.corner.moveTo(canvas.getObjects().indexOf(mainBg) + 1);
        }

        function createFadeRect(type, size) {
            const bgColor = document.getElementById('bgColor').value;
            const b = 2, wImg = mainBg.getScaledWidth(), hImg = mainBg.getScaledHeight();
            let w, h, x, y, c;
            if (type === 'left') { w = parseInt(size) + b; h = hImg + b*2; x = mainBg.left - b; y = mainBg.top - b; c = { x1: 0, y1: 0, x2: 1, y2: 0 }; }
            else if (type === 'right') { w = parseInt(size) + b; h = hImg + b*2; x = mainBg.left + wImg - size; y = mainBg.top - b; c = { x1: 1, y1: 0, x2: 0, y2: 0 }; }
            else if (type === 'top') { w = wImg + b*2; h = parseInt(size) + b; x = mainBg.left - b; y = mainBg.top - b; c = { x1: 0, y1: 0, x2: 0, y2: 1 }; }
            else if (type === 'bottom') { w = wImg + b*2; h = parseInt(size) + b; x = mainBg.left - b; y = mainBg.top + hImg - size; c = { x1: 0, y1: 1, x2: 0, y2: 0 }; }
            return new fabric.Rect({
                left: x, top: y, width: w, height: h, selectable: false, evented: false,
                fill: new fabric.Gradient({ type: 'linear', gradientUnits: 'percentage', coords: c, colorStops: [{ offset: 0, color: bgColor }, { offset: 1, color: hexToRgba(bgColor, 0) }] }),
                dataTag: 'fade_effect'
            });
        }

        function hexToRgba(hex, a) {
            let r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${a === 0 ? 0.005 : a})`;
        }

        function updateBgColor(skipRender = false) { 
            if(!canvas) return Promise.resolve(); 
            
            const bgColorHex = document.getElementById('bgColor').value;
            canvas.getObjects().forEach(obj => {
                if (obj.type === 'textbox' && obj.autoBackgroundColor && obj.backgroundColor) {
                    const c = new fabric.Color(obj.backgroundColor);
                    const currentOpacity = c.getSource()[3];
                    const rgb = new fabric.Color(bgColorHex).getSource();
                    obj.set('backgroundColor', `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${currentOpacity})`);
                }
            });

            return new Promise(resolve => {
                canvas.setBackgroundColor(bgColorHex, () => { 
                    updateFades(true); 
                    if (!skipRender) canvas.requestRenderAll(); 
                    resolve();
                });
            });
        }
        function openTab(evt, tabId) { document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active')); document.querySelectorAll('.tab-link').forEach(l => l.classList.remove('active')); document.getElementById(tabId).classList.add('active'); evt.currentTarget.classList.add('active'); }
        async function saveSettings() {
            const config = {
                general: {
                    overwrite_existing: document.getElementById('set-gen-overwrite').checked
                },
                jellyfin: {
                    url: document.getElementById('set-jf-url').value,
                    api_key: document.getElementById('set-jf-key').value,
                    user_id: document.getElementById('set-jf-user').value,
                    excluded_libraries: document.getElementById('set-jf-exclude').value
                },
                plex: {
                    url: document.getElementById('set-plex-url').value,
                    token: document.getElementById('set-plex-token').value
                },
                tmdb: {
                    api_key: document.getElementById('set-tmdb-key').value,
                    language: document.getElementById('set-tmdb-lang').value
                },
                radarr: {
                    url: document.getElementById('set-radarr-url').value,
                    api_key: document.getElementById('set-radarr-key').value
                },
                sonarr: {
                    url: document.getElementById('set-sonarr-url').value,
                    api_key: document.getElementById('set-sonarr-key').value
                },
                jellyseerr: {
                    url: document.getElementById('set-jellyseerr-url').value,
                    api_key: document.getElementById('set-jellyseerr-key').value
                },
                trakt: {
                    api_key: document.getElementById('set-trakt-key').value,
                    username: document.getElementById('set-trakt-user').value,
                    listname: document.getElementById('set-trakt-list').value
                },
                editor: {
                    resolution: document.getElementById('resSelect').value
                }
            };
            const resp = await fetch('/api/settings', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(config) });
            if(resp.ok) alert("Settings saved!");
        }
        function changeResolution() {
            if (gridEnabled) removeGrid();
            const res = document.getElementById('resSelect').value;
            const targetW = (res === '2160') ? 3840 : 1920;
            const scale = targetW / canvas.width;
            canvas.setDimensions({ width: targetW, height: (res === '2160' ? 2160 : 1080) });
            canvas.getObjects().forEach(obj => { obj.scaleX *= scale; obj.scaleY *= scale; obj.left *= scale; obj.top *= scale; obj.setCoords(); });
            if (gridEnabled) drawGrid();
            updateFades();
        }

        function openLightbox(layoutKey, index) {
            if (!loadedGalleryData || !loadedGalleryData[layoutKey]) return;
            
            lightboxImages = loadedGalleryData[layoutKey];
            currentLightboxIndex = index;
            
            document.getElementById('lightbox').style.display = 'flex';
            document.addEventListener('keydown', handleLightboxKeys);
            
            showLightboxImage(currentLightboxIndex);
        }

        function closeLightbox() {
            document.getElementById('lightbox').style.display = 'none';
            document.removeEventListener('keydown', handleLightboxKeys);
        }

        function showLightboxImage(index) {
            if (index < 0) index = lightboxImages.length - 1;
            if (index >= lightboxImages.length) index = 0;
            currentLightboxIndex = index;
            
            const layoutKey = Object.keys(loadedGalleryData).find(k => loadedGalleryData[k] === lightboxImages);
            const imgSrc = `/api/gallery/image/${layoutKey}/${lightboxImages[index]}`;
            document.getElementById('lightbox-img').src = imgSrc;
            document.getElementById('lightbox-edit-btn').onclick = () => editGalleryImage(layoutKey, lightboxImages[index]);
        }

        function changeLightboxImage(direction) {
            showLightboxImage(currentLightboxIndex + direction);
        }

        function handleLightboxKeys(e) {
            if (e.key === 'ArrowRight') {
                changeLightboxImage(1);
            } else if (e.key === 'ArrowLeft') {
                changeLightboxImage(-1);
            } else if (e.key === 'Escape') {
                closeLightbox();
            }
        }

        async function loadGallery() {
            const container = document.getElementById('gallery-content');
            container.innerHTML = '<p style="color:#888; text-align:center; margin-top:50px;">Loading images...</p>';
            
            try {
                const resp = await fetch('/api/gallery/list');
                const data = await resp.json();
                loadedGalleryData = data;
                
                if (Object.keys(data).length === 0) {
                    container.innerHTML = '<p style="color:#888; text-align:center; margin-top:50px;">No generated images found.</p>';
                    return;
                }

                let html = '';
                for (const [folder, images] of Object.entries(loadedGalleryData)) {
                    html += `<div class="gallery-section"><h2>${folder}</h2><div class="gallery-horizontal">`;
                    images.forEach((img, index) => {
                        const src = `/api/gallery/image/${folder}/${img}`;
                        html += `
                            <div class="gallery-item">
                                <img src="${src}" loading="lazy" onclick="openLightbox('${folder}', ${index})">
                                <div class="caption">${img}</div>
                                <button onclick="editGalleryImage('${folder}', '${img}')" style="position:absolute; top:5px; right:5px; width:auto; padding:4px 8px; font-size:12px; background:rgba(0,0,0,0.7); border:1px solid #fff; cursor:pointer; color:white;">‚úèÔ∏è</button>
                            </div>`;
                    });
                    html += `</div></div>`;
                }
                container.innerHTML = html;
            } catch (e) {
                console.error(e);
                container.innerHTML = '<p style="color:red; text-align:center;">Error loading gallery.</p>';
            }
        }
        function saveImage() { 
            const l = document.createElement('a'); 
            l.href = canvas.toDataURL({ format: 'jpeg', quality: 0.95 }); 
            let fname = 'tv-background.jpg';
            if (lastFetchedData && lastFetchedData.title) {
                const safeTitle = lastFetchedData.title.replace(/[^a-z0-9\s\.\-_]/gi, '').trim();
                const parts = [safeTitle];
                if(lastFetchedData.year && lastFetchedData.year !== 'N/A') parts.push(lastFetchedData.year);
                if(lastFetchedData.imdb_id) parts.push(lastFetchedData.imdb_id);
                fname = parts.join(' - ') + '.jpg';
            }
            l.download = fname; 
            l.click(); 
        }
        async function saveToGallery() {
            // Clear editing state if saving as new
            currentEditingFile = null;
            document.getElementById('btn-save-changes').style.display = 'none';
            await saveToGalleryInternal(document.getElementById('layoutName').value || "Default");
            alert("Image saved to Gallery!");
            loadGallery();
        }

        async function saveToGalleryInternal(layoutName, overwriteFilename = null) {
            const dataURL = canvas.toDataURL({ format: 'jpeg', quality: 0.95 });
            const json = canvas.toJSON(['dataTag', 'fullMediaText', 'selectable', 'evented', 'lockScalingY', 'splitByGrapheme', 'fixedHeight', 'editable', 'matchHeight', 'autoBackgroundColor']);
            
            const payload = { image: dataURL, layout_name: layoutName, canvas_json: json, overwrite_filename: overwriteFilename };
            
            if (lastFetchedData) {
                payload.metadata = { title: lastFetchedData.title, year: lastFetchedData.year, imdb_id: lastFetchedData.imdb_id };
            }
            await fetch('/api/save_image', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(payload)
            });
        }

        async function editGalleryImage(folder, filename) {
            const resp = await fetch(`/api/gallery/data/${encodeURIComponent(folder)}/${encodeURIComponent(filename)}`);
            const data = await resp.json();
            
            if (data.status === 'error') {
                alert("Cannot edit this image (no layout data found). Only images generated with the new editor version can be edited.");
                return;
            }
            
            canvas.loadFromJSON(data, () => {
                canvas.requestRenderAll();
                closeLightbox();
                openTab({currentTarget: document.querySelector('.tab-link')}, 'editor-tab');
                
                currentEditingFile = { folder: folder, filename: filename };
                document.getElementById('btn-save-changes').style.display = 'block';
                
                if (folder.startsWith("Layout: ")) {
                    document.getElementById('layoutName').value = folder.replace("Layout: ", "");
                }
            });
        }

        async function saveEditedImage() {
            if (!currentEditingFile) return;
            
            const layoutName = document.getElementById('layoutName').value || "Default";
            let overwrite = null;
            if (currentEditingFile.folder === `Layout: ${layoutName}`) {
                overwrite = currentEditingFile.filename;
            }
            
            await saveToGalleryInternal(layoutName, overwrite);
            alert("Changes saved!");
            loadGallery();
        }

        async function saveLayout() {
            const name = document.getElementById('layoutName').value;
            if (!name) return alert("Please enter a layout name");
            const layout = canvas.toJSON(['dataTag', 'fullMediaText', 'selectable', 'evented', 'lockScalingY', 'splitByGrapheme', 'fixedHeight', 'editable', 'matchHeight', 'autoBackgroundColor']);
            
            // Filter out fade effects and grid lines BEFORE saving
            layout.objects = layout.objects.filter(o => o.dataTag !== 'fade_effect' && o.dataTag !== 'grid_line');

            layout.custom_effects = {
                bgColor: document.getElementById('bgColor').value,
                bgBrightness: document.getElementById('bgBrightness').value,
                fadeEffect: document.getElementById('fadeEffect').value,
                fadeRadius: document.getElementById('fadeRadius').value,
                fadeLeft: document.getElementById('fadeLeft').value,
                fadeRight: document.getElementById('fadeRight').value,
                fadeTop: document.getElementById('fadeTop').value,
                fadeBottom: document.getElementById('fadeBottom').value,
                tagAlignment: document.getElementById('tagAlignSelect').value,
                genreLimit: document.getElementById('genreLimitSlider').value
            };

            const resp = await fetch('/api/layouts/save', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({name, layout}) });
            
            if(!resp.ok) return alert("Error saving layout");

            const btn = document.querySelector('button[onclick="saveLayout()"]');
            const originalText = btn.innerText;
            btn.disabled = true;

            try {
                for(let i=0; i<10; i++) {
                    btn.innerText = `Generating Previews (${i+1}/10)...`;
                    await fetchRandomPreview();
                    await saveToGalleryInternal(name);
                }
            } catch(e) { console.error(e); }
            
            btn.innerText = originalText;
            btn.disabled = false;
            alert("Layout saved and 10 example images generated!");
            loadLayoutsList();
        }

        async function loadLayoutsList() {
            const container = document.getElementById('layouts-content');
            const resp = await fetch('/api/layouts/list');
            const layouts = await resp.json();
            
            const galResp = await fetch('/api/gallery/list');
            loadedGalleryData = await galResp.json();

            let html = '';
            layouts.forEach(l => {
                const key = `Layout: ${l}`;
                let previews = '';
                if (loadedGalleryData[key]) {
                    loadedGalleryData[key].slice(0, 10).forEach((img, index) => {
                        const src = `/api/gallery/image/${key}/${img}`;
                        previews += `<img src="${src}" onclick="openLightbox('${key}', ${index})">`;
                    });
                } else { previews = '<span style="font-size:11px; color:#666;">No generated images yet.</span>'; }

                html += `<div class="layout-card">
                    <div class="layout-header">
                        <h3 style="margin:0; color:#fff; font-size:16px;">${l}</h3>
                        <div>
                            <button onclick="loadLayout('${l}')" style="width:auto; padding:5px 15px; font-size:12px;">üìÇ Load</button>
                            <button onclick="deleteLayout('${l}')" style="width:auto; padding:5px 15px; font-size:12px; background-color: #c62828; margin-left: 5px;">üóëÔ∏è Delete</button>
                        </div>
                    </div>
                    <div class="layout-previews">${previews}</div>
                </div>`;
            });
            container.innerHTML = html || '<p style="text-align:center; color:#666;">No saved layouts.</p>';
        }

        async function loadLayout(name) {
            const resp = await fetch(`/api/layouts/load/${name}`);
            if(!resp.ok) return alert("Error loading layout");
            const data = await resp.json();
            
            canvas.loadFromJSON(data, () => {
                canvas.renderAll();
                document.getElementById('layoutName').value = name;
                
                if (data.custom_effects) {
                    const eff = data.custom_effects;
                    if(eff.bgColor) { document.getElementById('bgColor').value = eff.bgColor; canvas.setBackgroundColor(eff.bgColor); }
                    if(eff.bgBrightness) document.getElementById('bgBrightness').value = eff.bgBrightness;
                    if(eff.fadeEffect) document.getElementById('fadeEffect').value = eff.fadeEffect;
                    if(eff.fadeRadius) document.getElementById('fadeRadius').value = eff.fadeRadius;
                    if(eff.fadeLeft) document.getElementById('fadeLeft').value = eff.fadeLeft;
                    if(eff.fadeRight) document.getElementById('fadeRight').value = eff.fadeRight;
                    if(eff.fadeTop) document.getElementById('fadeTop').value = eff.fadeTop;
                    if(eff.fadeBottom) document.getElementById('fadeBottom').value = eff.fadeBottom;
                    if(eff.tagAlignment) document.getElementById('tagAlignSelect').value = eff.tagAlignment;
                    else if(eff.centerTags !== undefined) document.getElementById('tagAlignSelect').value = eff.centerTags ? 'center' : 'left';
                    if(eff.limitGenres !== undefined) {
                        const val = eff.limitGenres ? 2 : 6;
                        document.getElementById('genreLimitSlider').value = val;
                        document.getElementById('genreLimitVal').innerText = (val == 6) ? "Max" : val;
                    }
                    if(eff.genreLimit !== undefined) {
                        document.getElementById('genreLimitSlider').value = eff.genreLimit;
                        document.getElementById('genreLimitVal').innerText = (eff.genreLimit == 6) ? "Max" : eff.genreLimit;
                    }
                    
                    updateFadeControls();
                    updateBgColor();
                }
                
                openTab({currentTarget: document.querySelector('.tab-link')}, 'editor-tab');
                alert(`Layout "${name}" loaded!`);
            });
        }

        async function deleteLayout(name) {
            if (!confirm(`Are you sure you want to delete the layout "${name}" and all its generated images? This cannot be undone.`)) {
                return;
            }
            const resp = await fetch(`/api/layouts/delete/${name}`, { method: 'POST' });
            if (resp.ok) {
                loadLayoutsList();
                loadGallery();
            } else {
                alert("Error deleting layout.");
            }
        }

        function mirrorBackground() {
            if (!mainBg) return;
            mainBg.set('flipX', !mainBg.flipX);
            canvas.requestRenderAll();
        }

        function saveToLocalStorage() {
            if (!canvas) return;
            const json = canvas.toJSON(['dataTag', 'fullMediaText', 'selectable', 'evented', 'lockScalingY', 'splitByGrapheme', 'fixedHeight', 'editable', 'matchHeight', 'autoBackgroundColor']);
            // Filter out fade effects so they aren't saved as static objects
            json.objects = json.objects.filter(o => o.dataTag !== 'fade_effect' && o.dataTag !== 'grid_line');
            
            json.custom_effects = {
                bgColor: document.getElementById('bgColor').value,
                bgBrightness: document.getElementById('bgBrightness').value,
                fadeEffect: document.getElementById('fadeEffect').value,
                fadeRadius: document.getElementById('fadeRadius').value,
                fadeLeft: document.getElementById('fadeLeft').value,
                fadeRight: document.getElementById('fadeRight').value,
                fadeTop: document.getElementById('fadeTop').value,
                fadeBottom: document.getElementById('fadeBottom').value,
                tagAlignment: document.getElementById('tagAlignSelect').value,
                genreLimit: document.getElementById('genreLimitSlider').value
            };
            json.lastFetchedData = lastFetchedData;
            localStorage.setItem('autosave_layout', JSON.stringify(json));
        }

        function loadFromLocalStorage() {
            const saved = localStorage.getItem('autosave_layout');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    lastFetchedData = data.lastFetchedData || null;
                    canvas.loadFromJSON(data, () => {
                        canvas.renderAll();
                        mainBg = canvas.getObjects().find(o => o.dataTag === 'background');
                        
                        // Cleanup: Remove any existing fade effects (tagged or untagged ghosts)
                        const ghosts = canvas.getObjects().filter(o => 
                            o.dataTag === 'fade_effect' || 
                            o.dataTag === 'grid_line' || 
                            (o.type === 'rect' && !o.selectable && !o.evented) ||
                            (o.type === 'line' && o.stroke === '#555' && !o.selectable) // Legacy grid cleanup
                        );
                        ghosts.forEach(g => canvas.remove(g));
                        
                        
                        // Fallback: If no background tag found, assume the first large image is the background
                        if (!mainBg && canvas.getObjects().length > 0) {
                            const firstObj = canvas.item(0);
                            if (firstObj && firstObj.type === 'image' && firstObj.width > 500) {
                                mainBg = firstObj;
                                mainBg.set('dataTag', 'background');
                            }
                        }
                        
                        if (data.custom_effects) {
                            const eff = data.custom_effects;
                            if(eff.bgColor) { document.getElementById('bgColor').value = eff.bgColor; canvas.setBackgroundColor(eff.bgColor, () => {}); }
                            if(eff.bgBrightness) document.getElementById('bgBrightness').value = eff.bgBrightness;
                            if(eff.fadeEffect) document.getElementById('fadeEffect').value = eff.fadeEffect;
                            if(eff.fadeRadius) document.getElementById('fadeRadius').value = eff.fadeRadius;
                            if(eff.fadeLeft) document.getElementById('fadeLeft').value = eff.fadeLeft;
                            if(eff.fadeRight) document.getElementById('fadeRight').value = eff.fadeRight;
                            if(eff.fadeTop) document.getElementById('fadeTop').value = eff.fadeTop;
                            if(eff.fadeBottom) document.getElementById('fadeBottom').value = eff.fadeBottom;
                            if(eff.tagAlignment) document.getElementById('tagAlignSelect').value = eff.tagAlignment;
                            else if(eff.centerTags !== undefined) document.getElementById('tagAlignSelect').value = eff.centerTags ? 'center' : 'left';
                            if(eff.limitGenres !== undefined) {
                                const val = eff.limitGenres ? 2 : 6;
                                document.getElementById('genreLimitSlider').value = val;
                                document.getElementById('genreLimitVal').innerText = (val == 6) ? "Max" : val;
                            }
                            if(eff.genreLimit !== undefined) {
                                document.getElementById('genreLimitSlider').value = eff.genreLimit;
                                document.getElementById('genreLimitVal').innerText = (eff.genreLimit == 6) ? "Max" : eff.genreLimit;
                            }
                            updateFadeControls();
                        }
                        updateFades();
                    });
                    return true;
                } catch(e) { console.error("Autosave load error", e); }
            }
            return false;
        }
        window.onload = init;
    </script>
</body>
</html>
